name: Deploy Runner + Bootstrap Backend + Terra

on:
  workflow_dispatch:

jobs:
  bootstrap-backend:
    runs-on: ubuntu-latest
    outputs:
      state_bucket: ${{ steps.out.outputs.bucket }}
      dynamodb_table: ${{ steps.out.outputs.table }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: "1.5.0"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-region: us-east-1
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Terraform Init (bootstrap backend)
        working-directory: bootstrap-backend
        run: terraform init -input=false -no-color

      - name: Terraform Apply (bootstrap backend)
        id: apply
        working-directory: bootstrap-backend
        run: |
          # Use deterministic bucket name OR pass in via workflow inputs/secrets
          TF_VAR_bucket_name="${{ secrets.TFSTATE_BUCKET_NAME }}" || true
          terraform apply -auto-approve -input=false -no-color \
            -var "bucket_name=${TF_VAR_bucket_name:-recipes-polyglot-state-$(date +%s)}" \
            -var "dynamodb_table=terraform-state-lock" \
            -var "environment=prod"
          # capture outputs via terraform output -json
          
      - name: Read bootstrap outputs (robust + sanitize)
        id: out
        working-directory: bootstrap-backend
        run: |
          set -euo pipefail

          # capture terraform output to a file (keep stderr separate)
          /home/runner/work/_temp/terraform-bin output -json > /tmp/tfout.raw 2>/tmp/tfout.err || true
          # (if you use a different terraform binary, use `terraform` instead of the explicit path above)

          # show a tiny preview so logs contain helpful debug info
          echo "=== terraform stdout preview ==="
          sed -n '1,120p' /tmp/tfout.raw || true
          echo "=== terraform stderr preview ==="
          sed -n '1,120p' /tmp/tfout.err || true

          # Extract the first JSON object found in the file by locating the first '{' and last '}'.
          # This strips any leading/trailing noise that can break jq parsing in CI.
          RAW="$(cat /tmp/tfout.raw || true)"
          # Find index of first '{' and last '}', then slice.
          FIRST=$(expr index "$RAW" '{' || echo 0)
          LAST_IDX=$(awk 'BEGIN{RS="";} { print length($0) }' <<< "$RAW") || true
          # If no '{' found, fail with diagnostics
          if [ "$FIRST" -eq 0 ]; then
            echo "ERROR: no JSON object found in terraform output file. Full raw output:" >&2
            sed -n '1,300p' /tmp/tfout.raw >&2 || true
            exit 1
          fi

          # Extract substring: from FIRST to last '}' in the raw content.
          # Use awk to print from the first '{' to the last '}'.
          JSON_CLEAN=$(awk 'BEGIN{found=0} { for(i=1;i<=length($0);i++){c=substr($0,i,1); if(c=="{" && found==0){start=i; found=1} if(c=="}"){end=i} } } END{ if(found==1) print substr($0,start,end-start+1); }' /tmp/tfout.raw || true)

          if [ -z "$JSON_CLEAN" ]; then
            echo "ERROR: failed to sanitize JSON from terraform output. Raw file:" >&2
            sed -n '1,300p' /tmp/tfout.raw >&2 || true
            exit 1
          fi

          # write sanitized JSON to a file and validate
          printf "%s\n" "$JSON_CLEAN" > /tmp/tfout.json
          if ! jq empty /tmp/tfout.json >/dev/null 2>&1; then
            echo "ERROR: sanitized terraform output is not valid JSON. Content:" >&2
            sed -n '1,300p' /tmp/tfout.json >&2 || true
            exit 1
          fi

          # Pull outputs (supports .value wrapper or direct value or single-element arrays)
          S3_BUCKET=$(jq -r '(.s3_bucket.value // .s3_bucket // (.s3_bucket[0] // empty) // empty) | tostring' /tmp/tfout.json || true)
          DDB_TABLE=$(jq -r '(.dynamodb_table.value // .dynamodb_table // (.dynamodb_table[0] // empty) // empty) | tostring' /tmp/tfout.json || true)

          if [ -z "$S3_BUCKET" ] || [ "$S3_BUCKET" = "null" ]; then
            echo "ERROR: could not extract s3_bucket from terraform output. Full sanitized JSON:" >&2
            sed -n '1,300p' /tmp/tfout.json >&2 || true
            exit 1
          fi
          if [ -z "$DDB_TABLE" ] || [ "$DDB_TABLE" = "null" ]; then
            echo "ERROR: could not extract dynamodb_table from terraform output. Full sanitized JSON:" >&2
            sed -n '1,300p' /tmp/tfout.json >&2 || true
            exit 1
          fi

          # Write outputs for GitHub Actions
          printf "bucket=%s\n" "$S3_BUCKET" >> "$GITHUB_OUTPUT"
          printf "table=%s\n" "$DDB_TABLE" >> "$GITHUB_OUTPUT"

          echo "Bootstrap outputs: bucket=$S3_BUCKET, table=$DDB_TABLE"



  terraform:
    needs: bootstrap-backend
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: "1.5.0"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-region: us-east-1
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Terraform Init
        working-directory: terra
        run: |
          terraform init -input=false -no-color \
            -backend-config="bucket=akshat-recipes-polyglot-tfstate" \
            -backend-config="key=k8s-infra/terraform.tfstate" \
            -backend-config="region=us-east-1" \
            -backend-config="dynamodb_table=akshat-recipes-polyglot-lock" \
            -backend-config="encrypt=true"

      - name: Terraform Apply
        working-directory: terra
        run: terraform apply -lock-timeout=10m -auto-approve -input=false -no-color

      - name: Get runner public IP (via AWS CLI)
        id: tfout
        run: |
          # find running instance by Name tag "Akshat-terra" and get its public IP
          IP=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=Akshat-terra" "Name=instance-state-name,Values=running" \
            --query "Reservations[].Instances[].PublicIpAddress" --output text | awk '{print $1}')
          IP=$(printf "%s" "$IP" | tr -d '\r\n')
          if [ -z "$IP" ] || [ "$IP" = "None" ]; then
            echo "Error: could not find public IP for instance with Name=Akshat-terra" >&2
            aws ec2 describe-instances --filters "Name=tag:Name,Values=Akshat-terra" --query "Reservations[].Instances[].[InstanceId,State.Name,PublicIpAddress,Tags]" --output table >&2 || true
            exit 1
          fi
          printf "IP=%s\n" "$IP" >> "$GITHUB_OUTPUT"


      - name: Request fresh GitHub org registration token
        id: regtoken2
        run: |
          ORG="Recipies-Polyglot-Org"
          RESP=$(curl -s -X POST -H "Authorization: token ${{ secrets.GH_PAT }}" -H "Accept: application/vnd.github+json" "https://api.github.com/orgs/${ORG}/actions/runners/registration-token")
          TOKEN=$(echo "$RESP" | jq -r .token)
          if [ -z "$TOKEN" ] || [ "$TOKEN" = "null" ]; then
            echo "Failed to obtain registration token"
            echo "$RESP" >&2
            exit 1
          fi
          printf "token=%s\n" "$TOKEN" >> "$GITHUB_OUTPUT"

      - name: Register runner via SSH (wait for SSH + register)
        id: sshreg
        env:
          SSH_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          RUNNER_IP: ${{ steps.tfout.outputs.IP }}
          REG_TOKEN: ${{ steps.regtoken2.outputs.token }}
        run: |
          set -euo pipefail

          if [ -z "${RUNNER_IP:-}" ]; then
            echo "RUNNER_IP is empty; aborting" >&2
            exit 1
          fi

          mkdir -p /tmp/sshkey
          printf "%s\n" "$SSH_KEY" > /tmp/sshkey/id_rsa
          chmod 600 /tmp/sshkey/id_rsa

          # wait for SSH port 22 to be open (timeout 300s)
          end=$((SECONDS + 300))
          echo "waiting for SSH on ${RUNNER_IP}..."
          while ! timeout 5 bash -c "</dev/tcp/${RUNNER_IP}/22" >/dev/null 2>&1; do
            if [ $SECONDS -gt $end ]; then
              echo "timeout waiting for SSH on ${RUNNER_IP}" >&2
              exit 1
            fi
            sleep 3
          done
          echo "SSH reachable"

          # create idempotent register script
          cat > /tmp/register.sh <<'SCRIPT'
          #!/bin/bash
          set -euo pipefail
          TOKEN="$1"
          RUNNER_DIR="/opt/actions-runner"
          
          # wait for apt/dpkg locks (max 300s)
          end=$((SECONDS+300))
          while fuser /var/lib/dpkg/lock >/dev/null 2>&1 \
            || fuser /var/lib/apt/lists/lock >/dev/null 2>&1 \
            || fuser /var/lib/apt/lists/lock-frontend >/dev/null 2>&1 \
            || ps -ef | grep -E "[a]pt|[a]pt-get|[d]pkg" | grep -v grep >/dev/null 2>&1; do
            if [ $SECONDS -gt $end ]; then
              echo "timed out waiting for apt locks" >&2
              exit 1
            fi
            sleep 3
          done
          
          # install runner files if missing
          if [ ! -d "$RUNNER_DIR" ] || [ ! -f "$RUNNER_DIR/config.sh" ]; then
            DEBIAN_FRONTEND=noninteractive apt-get update -y
            DEBIAN_FRONTEND=noninteractive apt-get install -y curl jq tar
            mkdir -p "$RUNNER_DIR"
            cd /tmp
            RUNNER_TGZ_URL=$(curl -s https://api.github.com/repos/actions/runner/releases/latest \
              | jq -r '.assets[] | select(.name | test("linux-x64.*tar.gz$")) | .browser_download_url')
            curl -sL "$RUNNER_TGZ_URL" -o actions-runner.tar.gz
            tar xzf actions-runner.tar.gz -C "$RUNNER_DIR"
          fi
          
          id -u githubrunner >/dev/null 2>&1 || useradd -m -s /bin/bash githubrunner
          chown -R githubrunner:githubrunner "$RUNNER_DIR"
          
          cd "$RUNNER_DIR" || { echo "runner dir missing"; exit 1; }
          
          sudo -u githubrunner bash -lc "./config.sh --unattended --url https://github.com/Recipies-Polyglot-Org --token \"$TOKEN\" --name runner-manual-$(hostname)-$(date +%s) --labels self-hosted,linux,X64 --work _work --replace || true"

          # create permissive sudoers entry for githubrunner (idempotent) - full privileges
          if [ ! -f /etc/sudoers.d/githubrunner ]; then
            sudo tee /etc/sudoers.d/githubrunner > /dev/null <<'SUDO'
          githubrunner ALL=(ALL) NOPASSWD: ALL
          SUDO
            sudo chmod 440 /etc/sudoers.d/githubrunner
          fi

          
          # create correct systemd unit (note multi-user.target)
          sudo bash -lc 'printf "%s\n" "[Unit]" "Description=GitHub Actions Runner" "After=network.target" "" "[Service]" "Type=simple" "User=githubrunner" "WorkingDirectory=/opt/actions-runner" "ExecStart=/opt/actions-runner/run.sh" "Restart=always" "RestartSec=5s" "" "[Install]" "WantedBy=multi-user.target" > /etc/systemd/system/github-runner.service' || true
          
          sudo systemctl daemon-reload || true
          sudo systemctl enable --now github-runner.service || true
          sudo systemctl status github-runner.service --no-pager || true
          SCRIPT

          chmod +x /tmp/register.sh

          scp -o StrictHostKeyChecking=no -i /tmp/sshkey/id_rsa /tmp/register.sh "ubuntu@${RUNNER_IP}:/tmp/register.sh"
          ssh -o StrictHostKeyChecking=no -i /tmp/sshkey/id_rsa "ubuntu@${RUNNER_IP}" "sudo /bin/bash /tmp/register.sh '${REG_TOKEN}'"

          echo "registration ssh step completed"
      
      - name: Wait for runner to be online then dispatch infra-apply workflow
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
          ORG: Recipies-Polyglot-Org
          WORKFLOW_FILE: infra-apply.yaml   
          REF: master                         
        run: |
          set -euo pipefail

          # derive owner/repo from the current repository
          OWNER_REPO="${{ github.repository }}"
          OWNER="${OWNER_REPO%%/*}"
          REPO="${OWNER_REPO#*/}"

          echo "Owner: $OWNER, Repo: $REPO"

          # Wait until at least one self-hosted runner in the org is online (timeout 3 minutes)
          echo "Waiting for an online self-hosted runner in org ${ORG}..."
          end=$((SECONDS + 180))
          found=""
          while [ $SECONDS -le $end ]; do
            runners_json=$(curl -s -H "Authorization: token ${GH_PAT}" -H "Accept: application/vnd.github+json" "https://api.github.com/orgs/${ORG}/actions/runners")
            # find any runner with status=online and a label named self-hosted
            found=$(echo "$runners_json" | jq -r '.runners[] | select(.status=="online") | select(.labels[].name=="self-hosted") | .name' | head -n1 || true)
            if [ -n "$found" ] && [ "$found" != "null" ]; then
              echo "Found online self-hosted runner: $found"
              break
            fi
            echo "No online runner yet. Sleeping 5s..."
            sleep 5
          done

          if [ -z "$found" ] || [ "$found" = "null" ]; then
            echo "Timed out waiting for an online self-hosted runner in org ${ORG} after 180s" >&2
            # choose to fail the job or continue silently; we fail here so you notice
            exit 1
          fi

          # Dispatch infra workflow in the same repository
          echo "Dispatching workflow ${WORKFLOW_FILE} on ${REF} in ${OWNER}/${REPO}..."
          resp=$(curl -s -o /dev/stderr -w "%{http_code}" -X POST \
            -H "Authorization: token ${GH_PAT}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${OWNER}/${REPO}/actions/workflows/${WORKFLOW_FILE}/dispatches" \
            -d "{\"ref\":\"${REF}\"}")
          if [ "$resp" != "204" ]; then
            echo "Failed to dispatch workflow: HTTP ${resp}" >&2
            exit 1
          fi
          echo "Workflow dispatched successfully."
