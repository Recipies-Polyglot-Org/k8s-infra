name: Infra Apply (Day-0 & Day-N)

on:
  workflow_dispatch: {}                  # Day-0: run manually
  push:                                  # Day-N: re-apply base when infra changes
    branches: [ "master" ]
    paths:
      - "base/**"
      - "scripts/**"
      - ".github/workflows/infra-apply.yaml"

concurrency:
  group: infra-apply
  cancel-in-progress: true

env:
  ORG: Recipies-Polyglot-Org
  SERVICES: |
    api-gate-microservice
    userdata-microservice
    suggest-microservice
    frontend-react

jobs:
  apply:
    runs-on: [self-hosted, linux, X64]
    steps:
      - uses: actions/checkout@v4

      # ---- Day-0 bootstrap (idempotent) ----
      - name: Bootstrap machine if needed
        run: |
          set -euo pipefail
          if ! command -v kubectl >/dev/null 2>&1 || ! kubectl get nodes >/dev/null 2>&1; then
            echo "Running bootstrap.sh..."
            sudo bash ./scripts/bootstrap.sh
          else
            echo "Cluster already initialized."
          fi

      # ---- Secrets (safe to re-run) ----
      - name: Create/Update AWS Secret
        run: |
          kubectl create secret generic aws-secrets \
            --from-literal=AWS_ACCESS_KEY_ID='${{ secrets.AWS_ACCESS_KEY_ID }}' \
            --from-literal=AWS_SECRET_ACCESS_KEY='${{ secrets.AWS_SECRET_ACCESS_KEY }}' \
            --from-literal=AWS_REGION='${{ secrets.AWS_REGION }}' \
            --dry-run=client -o yaml | kubectl apply -f -

      # ---- Base infra (recursive) ----
      - name: Apply Base
        run: kubectl apply -f base/metrics-server.yaml

      - name: Wait for kube-system and CNI to be Ready
        run: |
          echo "Waiting for kube-system pods to be ready..."
          kubectl wait --for=condition=Ready pod -n kube-system --all --timeout=300s

      # step 1
      - name: Apply ingress controller core (namespace/sa/rbac/service/deployment)
        run: kubectl apply -f base/ingress/controller-core.yaml

      - name: Wait for ingress-nginx controller pod(s) Ready
        run: |
          echo "Waiting for ingress controller pods to be Ready..."
          kubectl -n ingress-nginx wait --for=condition=Ready pod -l app.kubernetes.io/name=ingress-nginx --timeout=300s


      # step 2

      - name: Apply admission certgen jobs (create & patch)
        run: kubectl apply -f base/ingress/admission-jobs.yaml || true

      - name: Wait for admission jobs to complete and secret to appear
        run: |
          set -euo pipefail
          kubectl -n ingress-nginx wait --for=condition=complete job/ingress-nginx-admission-create --timeout=120s || echo "create job may already be complete"
          kubectl -n ingress-nginx wait --for=condition=complete job/ingress-nginx-admission-patch --timeout=120s || echo "patch job may already be complete"
          echo "Waiting for secret ingress-nginx-admission..."
          for i in $(seq 1 30); do
            if kubectl -n ingress-nginx get secret ingress-nginx-admission >/dev/null 2>&1; then
              echo "secret exists"; break
            fi
            sleep 2
          done
          kubectl -n ingress-nginx get secret ingress-nginx-admission -o yaml

      # step 3

      - name: Wait for admission endpoints to be populated
        run: |
          for i in $(seq 1 60); do
            subsets=$(kubectl -n ingress-nginx get endpoints ingress-nginx-controller-admission -o jsonpath='{.subsets}' 2>/dev/null || echo "")
            if [ -n "$subsets" ] && [ "$subsets" != "[]" ]; then
              echo "admission endpoints ready"; exit 0
            fi
            echo "waiting for admission endpoints..."
            kubectl -n ingress-nginx get pods -o wide
            sleep 5
          done
          echo "timed out waiting for admission endpoints" >&2
          kubectl -n ingress-nginx get endpoints ingress-nginx-controller-admission -o yaml
          exit 1

      # step 4

      - name: Apply ValidatingWebhookConfiguration and Ingress
        run: kubectl apply -f base/ingress/webhook-and-ingress.yaml


      - name: Snapshot
        run: |
          kubectl get nodes
          kubectl get deploy,svc,ingress -A
          kubectl get pods -A

  seed-services:
    if: ${{ github.event_name == 'workflow_dispatch' }}
    needs: apply
    runs-on: ubuntu-latest
    steps:
      - name: Trigger CI for all services
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}   # PAT with repo + workflow scopes
          ORG: Recipies-Polyglot-Org
          SERVICES: |
            api-gate-microservice
            userdata-microservice
            suggest-microservice
            frontend-react
        run: |
          set -euo pipefail
          while IFS= read -r REPO; do
            [ -z "$REPO" ] && continue
            echo "Triggering CI in $ORG/$REPO"
            gh workflow run CI --repo "$ORG/$REPO" --ref master || true
          done <<< "$SERVICES"
  
      - name: Wait for CI success (their CD will deploy)
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}   # same token; no login needed
          ORG: Recipies-Polyglot-Org
          SERVICES: |
            api-gate-microservice
            userdata-microservice
            suggest-microservice
            frontend-react
        run: |
          set -euo pipefail
          while IFS= read -r REPO; do
            [ -z "$REPO" ] && continue
            echo "Waiting for CI in $ORG/$REPO ..."
            sleep 5
            for i in {1..60}; do
              run=$(gh run list --repo "$ORG/$REPO" --workflow CI --branch master --limit 1 --json status,conclusion -q '.[0]')
              status=$(echo "$run" | jq -r '.status // ""')
              concl=$(echo "$run" | jq -r '.conclusion // ""')
              echo "status=$status conclusion=$concl"
              if [ "$concl" = "success" ]; then break; fi
              sleep 10
            done
            [ "$concl" = "success" ] || { echo "CI failed or timed out for $REPO"; exit 1; }
          done <<< "$SERVICES"
