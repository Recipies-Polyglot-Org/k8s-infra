name: Infra Apply (Day-0 & Day-N)

on:
  workflow_dispatch: {}                  # Day-0: run manually
  push:                                  # Day-N: re-apply base when infra changes
    branches: [ "master" ]
    paths:
      - "base/**"
      - "scripts/**"
      - ".github/workflows/infra-apply.yaml"

concurrency:
  group: infra-apply
  cancel-in-progress: true

env:
  ORG: Recipies-Polyglot-Org
  SERVICES: |
    api-gate-microservice
    userdata-microservice
    suggest-microservice
    frontend-react

jobs:
  apply:
    runs-on: [self-hosted, linux, X64]
    steps:
      - uses: actions/checkout@v4

      # ---- Day-0 bootstrap (idempotent) ----
      - name: Bootstrap machine if needed
        run: |
          set -euo pipefail
          if ! command -v kubectl >/dev/null 2>&1 || ! kubectl get nodes >/dev/null 2>&1; then
            echo "Running bootstrap.sh..."
            sudo bash ./scripts/bootstrap.sh
          else
            echo "Cluster already initialized."
          fi

      # ---- Secrets (safe to re-run) ----
      - name: Create/Update AWS Secret
        run: |
          kubectl create secret generic aws-secrets \
            --from-literal=AWS_ACCESS_KEY_ID='${{ secrets.AWS_ACCESS_KEY_ID }}' \
            --from-literal=AWS_SECRET_ACCESS_KEY='${{ secrets.AWS_SECRET_ACCESS_KEY }}' \
            --from-literal=AWS_REGION='${{ secrets.AWS_REGION }}' \
            --dry-run=client -o yaml | kubectl apply -f -

      # ---- Base infra (recursive) ----
      - name: Apply Base
        run: kubectl apply -R -f base/

      - name: Snapshot
        run: |
          kubectl get nodes
          kubectl get deploy,svc,ingress -A
          kubectl get pods -A

  seed-services:
    # Only run when the workflow was manually dispatched (Day-0)
    if: ${{ github.event_name == 'workflow_dispatch' }}
    needs: apply
    runs-on: ubuntu-latest
    steps:
      - name: Authenticate gh
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}    # PAT with "repo" scope
        run: echo "$GH_TOKEN" | gh auth login --with-token

      - name: Trigger CI for all services
        env:
          ORG: ${{ env.ORG }}
          SERVICES: ${{ env.SERVICES }}
        run: |
          set -euo pipefail
          while read -r REPO; do
            [ -z "$REPO" ] && continue
            echo "Triggering CI in $ORG/$REPO"
            gh workflow run CI --repo "$ORG/$REPO" --ref master || true
          done <<< "$SERVICES"

      - name: Wait for CI success (their CD will deploy)
        env:
          ORG: ${{ env.ORG }}
          SERVICES: ${{ env.SERVICES }}
        run: |
          set -euo pipefail
          while read -r REPO; do
            [ -z "$REPO" ] && continue
            echo "Waiting for CI in $ORG/$REPO ..."
            # give the run a moment to show up
            sleep 5
            for i in {1..60}; do
              run=$(gh run list --repo "$ORG/$REPO" --workflow CI --branch master --limit 1 --json status,conclusion -q '.[0]')
              status=$(echo "$run" | jq -r '.status // ""')
              concl=$(echo "$run" | jq -r '.conclusion // ""')
              echo "status=$status conclusion=$concl"
              if [ "$concl" = "success" ]; then break; fi
              sleep 10
            done
            [ "$concl" = "success" ] || { echo "CI failed or timed out for $REPO"; exit 1; }
          done <<< "$SERVICES"
