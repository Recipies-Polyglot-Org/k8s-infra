name: Infra Apply (Day-0 & Day-N)

on:
  workflow_dispatch: {}                  # Day-0: run manually
  push:                                  # Day-N: re-apply base when infra changes
    branches: [ "master" ]
    paths:
      - "base/**"
      - "scripts/**"
      - ".github/workflows/infra-apply.yaml"

concurrency:
  group: infra-apply
  cancel-in-progress: true

env:
  ORG: Recipies-Polyglot-Org
  SERVICES: |
    api-gate-microservice
    userdata-microservice
    suggest-microservice
    frontend-react

jobs:
  apply:
    runs-on: [self-hosted, linux, X64]
    steps:
      - uses: actions/checkout@v4

      # ---- Day-0 bootstrap (idempotent) ----
      - name: Bootstrap machine if needed
        run: |
          set -euo pipefail
          if ! command -v kubectl >/dev/null 2>&1 || ! kubectl get nodes >/dev/null 2>&1; then
            echo "Running bootstrap.sh..."
            sudo bash ./scripts/bootstrap.sh
          else
            echo "Cluster already initialized."
          fi

      # ---- Secrets (safe to re-run) ----
      - name: Create/Update AWS Secret
        run: |
          kubectl create secret generic aws-secrets \
            --from-literal=AWS_ACCESS_KEY_ID='${{ secrets.AWS_ACCESS_KEY_ID }}' \
            --from-literal=AWS_SECRET_ACCESS_KEY='${{ secrets.AWS_SECRET_ACCESS_KEY }}' \
            --from-literal=AWS_REGION='${{ secrets.AWS_REGION }}' \
            --dry-run=client -o yaml | kubectl apply -f -

      # ---- Base infra (recursive) ----
      - name: Apply Base
        run: |
          kubectl apply -f base/metrics-server.yaml
          sleep 40


      # step 1
      - name: Apply ingress controller 
        run: kubectl apply -f base/ingress/ingress-controller.yaml

      - name: Wait for ingress-nginx controller pod(s) Ready
        run: |
          echo "Waiting for ingress controller pods to be Ready..."
          sleep 60

      - name: Apply ingress
        run: kubectl apply -f base/ingress/ingress.yaml

     
      - name: Snapshot
        run: |
          kubectl get nodes
          kubectl get deploy,svc,ingress -A
          kubectl get pods -A

  seed-services:
    if: ${{ github.event_name == 'workflow_dispatch' }}
    needs: apply
    runs-on: ubuntu-latest
    steps:
      - name: Trigger + wait CI in sequence
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}   # PAT with repo + workflow scopes
          ORG: Recipies-Polyglot-Org
          # ORDER MATTERS: userdata -> suggest -> api-gate -> frontend
          SERVICES: |
            userdata-microservice
            suggest-microservice
            api-gate-microservice
            frontend-react
          # tuning
          MAX_POLL_MINUTES: 20
          POLL_INTERVAL: 10
        run: |
          set -euo pipefail
  
          # helper: wait for the latest CI run on a repo to finish and be successful
          wait_for_ci_success() {
            local repo="$1"
            local max_minutes="${MAX_POLL_MINUTES}"
            local poll_interval="${POLL_INTERVAL}"
            local attempts=$(( (max_minutes * 60) / poll_interval ))
            echo "Waiting for CI (workflow: CI) on $ORG/$repo to complete (timeout: ${max_minutes}m)..."
  
            for i in $(seq 1 $attempts); do
              # get most recent run for workflow=CI on master branch
              run_json=$(gh run list --repo "$ORG/$repo" --workflow CI --branch master --limit 1 --json databaseId,status,conclusion,headSha -q '.[0]' 2>/dev/null || true)
  
              if [ -z "$run_json" ] || [ "$run_json" = "null" ]; then
                echo "  no recent CI run found yet for $repo (attempt $i/$attempts)."
                sleep "$poll_interval"
                continue
              fi
  
              status=$(echo "$run_json" | jq -r '.status // empty')
              concl=$(echo "$run_json" | jq -r '.conclusion // empty')
              id=$(echo "$run_json" | jq -r '.databaseId // empty')
              sha=$(echo "$run_json" | jq -r '.headSha // empty')
  
              echo "  run id=$id sha=${sha:0:7} status='$status' conclusion='$concl' (attempt $i/$attempts)"
  
              if [ "$status" = "completed" ]; then
                if [ "$concl" = "success" ]; then
                  echo "  CI succeeded for $repo (run id $id)."
                  return 0
                else
                  echo "  CI completed but conclusion='$concl' for $repo. Failing."
                  return 2
                fi
              fi
  
              # still running / queued
              sleep "$poll_interval"
            done
  
            echo "Timed out waiting for CI success for $repo after ${max_minutes} minutes."
            return 3
          }
  
          # trigger + wait sequentially
          while IFS= read -r REPO; do
            [ -z "$REPO" ] && continue
            echo "=== REPO: $REPO ==="
  
            echo "Triggering CI workflow in $ORG/$REPO..."
            # attempt to dispatch CI workflow; allow failure (repo may already auto-run on push)
            gh workflow run CI --repo "$ORG/$REPO" --ref master || true
  
            # small backoff so GH shows the run
            sleep 3
  
            # wait for the triggered run to succeed
            wait_for_ci_success "$REPO"
            rc=$?
            if [ $rc -eq 0 ]; then
              echo "CI for $REPO succeeded. Proceeding to next repo."
            elif [ $rc -eq 2 ]; then
              echo "CI for $REPO finished but did not succeed. Aborting pipeline."
              exit 1
            else
              echo "CI for $REPO timed out. Aborting pipeline."
              exit 1
            fi
  
          done <<< "$SERVICES"
  
          echo "All services' CI workflows finished successfully in sequence."
  
  
