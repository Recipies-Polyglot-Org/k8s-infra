name: Infra Apply (Day-0 & Day-N)

on:
  workflow_dispatch: {}              # Day-0: trigger manually
  push:                              # Day-N: auto-apply when infra YAMLs change
    branches: [ "master" ]
    paths:
      - "base/**"
      - ".github/workflows/**"
      - "scripts/**"

concurrency:
  group: infra-apply
  cancel-in-progress: true

env:
  ORG: Recipies-Polyglot-Org
  # repo list (exact repo names)
  SERVICES: |
    api-gate-microservice
    userdata-microservice
    suggest-microservice
    frontend-react

jobs:
  apply:
    runs-on: [self-hosted, linux, X64]
    steps:
      - uses: actions/checkout@v4

      # ---- Day-0 bootstrap (idempotent) ----
      - name: Bootstrap machine if needed
        run: |
          set -euo pipefail
          if ! command -v kubectl >/dev/null 2>&1 || ! kubectl get nodes >/dev/null 2>&1; then
            echo "Running bootstrap.sh..."
            sudo bash ./scripts/bootstrap.sh
          else
            echo "Cluster already initialized."
          fi

      # ---- Secrets (safe to re-run) ----
      - name: Create/Update AWS Secret
        run: |
          kubectl create secret generic aws-secrets \
            --from-literal=AWS_ACCESS_KEY_ID='${{ secrets.AWS_ACCESS_KEY_ID }}' \
            --from-literal=AWS_SECRET_ACCESS_KEY='${{ secrets.AWS_SECRET_ACCESS_KEY }}' \
            --from-literal=AWS_REGION='${{ secrets.AWS_REGION }}' \
            --dry-run=client -o yaml | kubectl apply -f -

      # ---- Base infra (recursive apply) ----
      - name: Apply Base
        run: kubectl apply -R -f base/

      # ---- Snapshot ----
      - name: Snapshot
        run: |
          kubectl get nodes
          kubectl get deploy,svc,ingress -A
          kubectl get pods -A

  # Day-0 only: trigger service builds so their repo-level CD deploys them
  seed-services:
  if: ${{ github.event_name == 'workflow_dispatch' }}
  needs: apply
  runs-on: ubuntu-latest
  steps:
    - name: Authenticate gh
      env:
        GH_TOKEN: ${{ secrets.GH_PAT }}   # PAT with repo scope
      run: echo "$GH_TOKEN" | gh auth login --with-token

    - name: Trigger CI for all services
      env:
        ORG: Recipies-Polyglot-Org
      run: |
        set -euo pipefail
        SERVICES="api-gate-microservice userdata-microservice suggest-microservice frontend-react"
        for REPO in $SERVICES; do
          echo "Triggering CI in $ORG/$REPO"
          gh workflow run CI --repo "$ORG/$REPO" --ref master || true
        done

    - name: Wait for CI success (their CD will deploy)
      env:
        ORG: Recipies-Polyglot-Org
        GH_TOKEN: ${{ secrets.GH_PAT }}
      run: |
        set -euo pipefail
        SERVICES="api-gate-microservice userdata-microservice suggest-microservice frontend-react"
        for REPO in $SERVICES; do
          echo "Waiting for CI in $ORG/$REPO ..."
          # give the run a moment to appear
          sleep 5
          for i in {1..60}; do
            run=$(gh run list --repo "$ORG/$REPO" --workflow CI --branch master --limit 1 --json status,conclusion -q '.[0]')
            status=$(echo "$run" | jq -r '.status // ""')
            concl=$(echo "$run" | jq -r '.conclusion // ""')
            echo "status=$status conclusion=$concl"
            if [ "$concl" = "success" ]; then break; fi
            sleep 10
          done
          [ "$concl" = "success" ] || { echo "CI failed or timed out for $REPO"; exit 1; }
        done

